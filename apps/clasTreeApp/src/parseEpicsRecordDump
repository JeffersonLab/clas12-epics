#!/bin/awk -f
#Run like this:
# or   ./parseEpicsRecordDump -v outname="name" ioc1.dump ioc2.dump ioc3.dump .....
#
#The purpose if this file is to take the records dumped from a group of EPICS iocs and make a hierarchy of nodes (similar to a filesystem)
#which makes it easy to navigate the whole EPICS slow control system.
#
# The output from the >dbDumpRecord command on an ioc is like this:
#
#...
#...
#record(ao,"B_HVDC1_Sl00_Ch00:i0set") {
#        field(DESC,"analog output record")
#        field(DTYP,"Soft Channel")
#..
#..
#}
#
#record(ao,"B_HVDC1_Sl00_Ch00:rampdn") {
#        field(DESC,"analog output record")
#        field(DTYP,"Soft Channel")
#..
#..
#}
#...
#...
#alias("B_HVDC1_Sl02_Ch16:i0set","B_HV_DC_Sec1_R1_SL1_F01-08:i0set")
#alias("B_HVDC1_Sl02_Ch16:rampdn","B_HV_DC_Sec1_R1_SL1_F01-08:rampdn")
#...
#...
#
# (The ailases come after the records in the dump, which is important in the mail awk loop.

#The concept depends on the EPICS records being named according to a well defined scheme, where layers of the Hierarchy are separated by 
#underscores(_), and the recored name comes after the final colon (:)
#The records and aliases (see above) are parsed into nodes. The nodes can be made into an EPICS records, dictionary, 
#used to generate alarm tables,GUIs etc. 
#It's easy to add another function to generate code based on the nodes.

#All nodes have the same form, with some fields remaining empty, depending on the position in the hierarchy. Here is a typical node:

#NodeName:            B_HV_DC_Sec6_R3_SL1
#ParentName:          B_HV_DC_Sec6_R3
#Depth:               5
#SubNodeCount:        0
#SubNodeNames:            
#ElementCount:        18
#ElementNames:        F01-08 F09-16 F17-24 F25-32 F33-48 F49-64 F65-80 F81-112 G01-32 G33-112 S01-08 S09-16 S17-24 S25-32 S33-48 S49-64 S65-80 S81-112
#ElementRecordCount:  6
#ElementRecordNames:  i0set rampdn rampup trip v0set pwonoff
#ElementRecordTypes:  ao ao ao ao ao bo
#NodeRecordCount:     0
#NodeRecordNames:         
#NodeRecordTypes:         

#The details are described on the wiki (https://clasweb.jlab.org/wiki/index.php/Slow_Control_EPICS_Record_Management).

BEGIN{
    if(topdir){                                              #if making dirtree (-v topdir="dirname" on the command line)
	if(!system("test -d \""topdir"\"")){                     #check if topdir already exists
	    print "";
	    print "WARNING:", topdir, "already exists";          #warn and ask for confirmation
	    print "           That may be what you want.";
	    print "           no directories will be deleted, but existing nodeInfo.txt files may be overwritten";
	    print "";
	    if(promptMe("Do you want to continue") == "n") exit;  #get y/n response, exit if no 
	}	    
	else{                                                #topdir doesn't exst
	    str=sprintf("Create new directory %s",topdir);       #ask if it's ok to make the dir
	    if(promptMe(str) == "n") exit;                       # get y/n response, exit if no                   
	    
	    str=sprintf("mkdir -p %s",topdir);                   #make the mkdir command and issue it
	    system(str);
	}
    }
}

#This is the main loop, which is called for every line in the .dump files.
#See the awk manual. $0 is the string containing the current line.
#                    $1, $2 ... are the fields within $0 separated by whitespace.
{
    if(($0~"record")&&($0~"{")){         #Parses records (eg. starting like this: record(ao,"B_HVDC1_Sl2_Ch23:rampup") {
	gsub(/[(,):\"]/," ");            #sub the ()," with spaces ->             record ao  B_HVDC1_Sl2_Ch23 rampup
	                                 #                                           $1  $2      $3	    $4
	type=$2; name=$3; rec=$4;        #give them decent names                        type    name        rec


	allcount[name] += addToStringInArray(allrecords,name,rec," ",0);
	addToStringInArray(alltypes,name,type," ",0);
	
	while($0!~"}"){                  #loop over the remainder of the record def
	    getline;                     #and do anything special if required
	    #nothing yet...
	}
    }

    if($0~"alias"){                      #parse the alias 
                                         #eg.        alias("B_HVDC1_2_23:rampup","B_HV_DC_Sec1_R1_SL1_F81-112:rampup")
	gsub(/[(,):\"]/," ");	         #sub to     alias  B_HVDC1_2_23 rampup   B_HV_DC_Sec1_R1_SL1_F81-112 rampup
	                                 #           $1         $2         $3              $4
	real=$2; name=$4;                #give decent names    real                       alias                                
	allrecords[name]=allrecords[real];     #copy info from real name to aliased name as new recrord.
	alltypes[name] = alltypes[real];    
    }

    #work down the chain making nodes etc as required
    nr=split(name,nodes,"_");            #split the name into nodes
    nodename="";                         #init to ""
    for(n=1;n<=nr;n++){                  #for all the nodes in the record name
	parent=nodename;                 #save the old nodename as the parent
	if(n==1) nodename = nodes[n];    #if first one, start the nodename
	else nodename=sprintf("%s_%s",nodename,nodes[n]);  #else append to the nodename
	
	if(n==nr){                       #it's an element - ie the last bit with the :record on it
	    RecordNames[nodename] = allrecords[nodename]; #copy the record etc to the element array
	    RecordTypes[nodename] = alltypes[nodename];
	    RecordCount[nodename] = allcount[nodename];
	}
	else{                            #its a subnode
	    if(SubNodeNames[nodename]){  #if list is started
		havesn=0;                #counter for  matches with existing subnodes in the list
		nsn=split(SubNodeNames[nodename],snodes," "); #split into list
		for(sn=1;sn<=nsn;sn++){
		    if(snodes[sn]==nodes[n+1]) havesn++;      #if match, inc counter
		}
		if(havesn==0){
		    SubNodeNames[nodename]= sprintf("%s %s",SubNodeNames[nodename],nodes[n+1]);
		    SubNodeCount[nodename]++;
		}
	    }
	    else{
		SubNodeNames[nodename] = nodes[n+1];
		SubNodeCount[nodename]++;
	    }
	}
	parents[nodename]=parent;        #save the node and it's parent
	depth[nodename]=n-1;             #save the depth
    }
}
        

END{

    nNodes=asorti(parents,NodeNames); # sort all into a new tidy arrays of ordered node names

    #need to go through all the nodes looking at the children.
    #find the elements of the children.
    #
    #
    #need to categorise subnodes as element, subnode or both.
    #for the group of subnodes which have most, or all records lists the same
    #we assume these are identical and class them as elements.
    #If any of them have subdirs, they are also classed as subnodes.
    #If not, they are removed from the list of subnodes, and from the big list of nodes.
    #Fill  fresh arrays, beginning A, with all the sorted.

    for(n=1;n<=nNodes;n++){

	delete recCount;                                 #delete previous array

	nodename                     = NodeNames[n];     #get the node name 
	AElementCount[nodename]      = 0;                #init the counters for the node            
	ASubNodeCount[nodename]      = 0;
	AElementRecordCount[nodename]= 0;
	ANodeRecordCount[nodename]   = 0;
	
	if(SubNodeCount[nodename]>=1){                    #if some subnodes
	    nsn=split(SubNodeNames[nodename],snodes," "); #split into list
	    for(sn=1;sn<=nsn;sn++){                        
		subname=sprintf("%s_%s",nodename,snodes[sn]); #make the full name of the subnode
		if(RecordNames[subname]){                 #if the subnode is also an element (has a record list)
		    recCount[RecordNames[subname]]++;     #inc record list's count of elements
		}
	    }
	    maxcount=1;                                   #set counter of no of elements with same record list
	    for(x in recCount){                           #loop over all record lists
		if(recCount[x]>maxcount){                 #find that with most elements
		    maxcount=recCount[x];                 #store current max   
		    elemrec=x;                            #and associated record list
		}
	    }

	    if(maxcount > 1){                             #mode than one subnode with the same record list
		for(sn=1;sn<=nsn;sn++){                        
		    subname=sprintf("%s_%s",nodename,snodes[sn]); #make ths full name of the subnode
		    if(RecordNames[subname]==elemrec){     #if this is a subnode containing the recordlist required
			AElementRecordNames[nodename] = RecordNames[subname];
			AElementRecordTypes[nodename] = RecordTypes[subname];
			AElementRecordCount[nodename] = RecordCount[subname];
			
			ElementCount[nodename] += addToStringInArray(ElementNames,nodename,snodes[sn]," ",1);

			if(SubNodeCount[subname]){        #if the element has a further subnoode
			    ASubNodeCount[nodename] += addToStringInArray(ASubNodeNames,nodename,snodes[sn]," ",1);
			}
		    }

		    else{
			ASubNodeCount[nodename] += addToStringInArray(ASubNodeNames,nodename,snodes[sn]," ",1);
		    }
		}
		
		AElementCount[nodename]       = ElementCount[nodename];
		AElementNames[nodename]       = ElementNames[nodename];
	    }
	    #loop over the subname and add any which didn't fall into the above category, but has further subdirs
	    for(sn=1;sn<=nsn;sn++){
		subname=sprintf("%s_%s",nodename,snodes[sn]); #make this full name of the subnode
		if(SubNodeCount[subname]){                    #if there is a further subnode
		    if(ASubNodeNames[nodename]){              #if there's already a subnode list
			havesn=0;
			na=split(ASubNodeNames[nodename],a," ");
			for(s=1;s<=na;s++){
			    if(a[s]==snodes[sn]) havesn++;
			}
			if(havesn==0){
			    ASubNodeNames[nodename]=sprintf("%s %s",ASubNodeNames[nodename],snodes[sn]);
			    ASubNodeCount[nodename]++; 
		    	}
		    }
		    else{
			
			ASubNodeNames[nodename]=snodes[sn];   #or start the list
			ASubNodeCount[nodename]++; 
		    }
		}
	    }
	}
	else{                                                              #node has records only
	    ASubNodeCount[nodename]         = 0;                           #no subnodes
	    AElementCount[nodename]         = 0;                           #no elements
	}

	if((ASubNodeCount[nodename]>0)||(AElementCount[nodename]>0)){      #If it has subnodes or elements we save it
	    AParentNames[nodename]          = parents[nodename];           #This array defines the ones.
	    ADepth[nodename]                = depth[nodename];             
	}
    }	

    nNodes=asorti(AParentNames,ANodeNames);        # sort all into a new tidy arrays of ordered node names

    "date"|getline;ldate=$0;                       #get the date to timestamp outputfiles 
    
    printAll("/dev/stdout");                       #print to stdout
    if(topdir) makeDirTree(topdir);                #make the directory tree if required
    
    pythonfile=sprintf("%sNodesDict.py",outname); #print the dictionary for python
    printDict(pythonfile);                         
#    printDict("clas12-nodesDict.py");
    
    dbfile=sprintf("../Db/%sNodes",outname);            #print the db files
    printDb(dbfile);
#    printDb("clas12-nodesEpics");
}		



### Functions used in the BEGIN{}, {} and END{} are defined below here

function printAll(outfile){
    printTopComments(outfile);          #print some comments at the top of file 
    for(n=1;n<=nNodes;n++){
	name = ANodeNames[n];           #get the node name for simplicity
	printNode(name, outfile);
    }
}

function makeDirTree(topdir){

    for(n=1;n<=nNodes;n++){
	name = ANodeNames[n];           #get the node name for simplicity
	fullname=name;
	gsub("_","/",fullname);
	fullname=sprintf("%s/%s",topdir,fullname);
	if(ADepth[name]==0){
	    command=sprintf("mkdir %s; cd %s; mkdir -p %s",fullname,fullname,ASubNodeNames[name]);
	    system(command);
	    print command;
	}
	else{
	    if(ASubNodeCount[name]>0){          #if the children are subnodes make directories
		#command=sprintf("mkdir -p %s; cd %s; mkdir -p %s",fullname,fullname,ASubNodeNames[name]);
		command=sprintf("cd %s; mkdir %s",fullname,ASubNodeNames[name]);
		system(command);
		print command;
	    }
	}
	nodedata=sprintf("%s/nodeInfo.txt",fullname);
	#print name,nodedata;
	printTopComments(nodedata); #print some comments at the top of each file 
	printNode(name, nodedata);  #print the node
    }
}
	
function printNode(name, outfile){
    
    print "NodeName:           ", name                         >> outfile;
    print "ParentName:         ", AParentNames[name]           >> outfile;
    print "Depth:              ", ADepth[name]                 >> outfile;
    print "SubNodeCount:       ", ASubNodeCount[name]          >> outfile;
    print "SubNodeNames:       ", ASubNodeNames[name]          >> outfile;
    print "ElementCount:       ", AElementCount[name]          >> outfile;
    print "ElementNames:       ", AElementNames[name]          >> outfile;
    print "ElementRecordCount: ", AElementRecordCount[name]    >> outfile;
    print "ElementRecordNames: ", AElementRecordNames[name]    >> outfile;
    print "ElementRecordTypes: ", AElementRecordTypes[name]    >> outfile;
    print "NodeRecordCount:    ", ANodeRecordCount[name]       >> outfile;
    print "NodeRecordNames:    ", ANodeRecordNames[name]       >> outfile;
    print "NodeRecordTypes:    ", ANodeRecordTypes[name]       >> outfile;
    print ""                                                   >> outfile;
}


function printDb(outfile){


    initfile=sprintf("%s.init",outfile);  #start file for initislising the waveform strings
    subfile=sprintf("%s.substitutions",outfile);    #start file for substitutions

    #put comments that the top of the substitutions file
    print "#This file was autogenerated by the parseEpicsRecordDump command on:",ldate > subfile;
    print "" >> subfile;   
    
    print "#To create the wave form (these are the names with with an L appended)" >> subfile;
    print "#"
    print "#P    = Prefix" >> subfile;
    print "#PNL  = String length of $(P):ParentName" >> subfile;     
    print "#D    = Depth" >> subfile;
    print "#SNC  = SubNodeCount" >> subfile;
    print "#SNNL = String length of $(P):SubNodeNames" >> subfile;
    print "#EC   = ElementCount" >> subfile;
    print "#ENL  = String length of $(P):ElementNames" >> subfile;
    print "#ERC  = ElementRecordCount" >> subfile;
    print "#ERNL = String length of $(P):ElementRecordNames" >> subfile;
    print "#ERTL = String length of $(P):ElementRecordTypes" >> subfile;
    print "#NRC  = NodeRecordCount" >> subfile;
    print "#NRNL = String length of $(P):NodeRecordNames" >> subfile;
    print "#NRTL = String length of $(P):NodeRecordTypes" >> subfile;
    print "" >> subfile;
    print "file \"db/nodes.db\" {" >> subfile;
    print " pattern  {	                      P,    PNL,      D,    SNC,   SNNL,    EC,     ENL,    ERC,   ERNL,   ERTL,    NRC,   NRNL,   NRTL}" >> subfile;


    #put comments that the top of the init file
    print "# This file was autogenerated by the parseEpicsRecordDump command on:",ldate > initfile;
    print "" >> initfile;   
    
    print  "# All strings are waveforms to allow over 40chars, so need to know, for each, how long the string is to create the PV" >> subfile;
    print  "# The wavefore cannot be initialised until after iocInit(), so the dbpb() commands to do this are in a partner" >> subfile;
    printf "# initialisation file: %s\n",initfile  >> subfile;
    printf "# This gets piped in to the ioc after the iocInit command is run ( <  %s )\n",initfile >> subfile; 
	

    for(n=1;n<=nNodes;n++){
	name = ANodeNames[n];           #get the node name for simplicity
	#give things their macro names and put quotes round them to make it easier,
	#and make waveform arrays 2 chars bigger than the string length.

	P   = sprintf("\"%s\",",name); #comma appended to make the printout of the sub file tidy
	PNL = sprintf("\"%s\",",length(AParentNames[name])+2);          PN  = sprintf("\"%s\",", AParentNames[name]); 
	D   = sprintf("\"%s\",",ADepth[name]);
	SNC = sprintf("\"%s\",",ASubNodeCount[name]);
	SNNL= sprintf("\"%s\",",length(ASubNodeNames[name])+2);         SNN = sprintf("\"%s\"", ASubNodeNames[name]);
	EC  = sprintf("\"%s\",",AElementCount[name]);
	ENL = sprintf("\"%s\",",length(AElementNames[name])+2);          EN = sprintf("\"%s\"", AElementNames[name]);
	ERC = sprintf("\"%s\",",AElementRecordCount[name]);
	ERNL= sprintf("\"%s\",",length(AElementRecordNames[name])+2);   ERN = sprintf("\"%s\"", AElementRecordNames[name]);
	ERTL= sprintf("\"%s\",",length(AElementRecordTypes[name])+2);   ERT = sprintf("\"%s\"", AElementRecordTypes[name]); 
	NRC = sprintf("\"%s\",",ANodeRecordCount[name]);
	NRNL = sprintf("\"%s\",",length(ANodeRecordNames[name])+2);     NRN = sprintf("\"%s\"", ANodeRecordNames[name]);
	NRNT = sprintf("\"%s\"}",length(ANodeRecordTypes[name])+2);     NRT = sprintf("\"%s\"", ANodeRecordTypes[name]);

	printf"{%40s%8s%8s%8s%8s%8s%8s%8s%8s%8s%8s%8s%8s\n",P,PNL,D,SNC,SNNL,EC,ENL,ERC,ERNL,ERTL,NRC,NRNL,NRNT >> subfile;
	
	printf"dbpf(\"%s:ParentName\",\"%s\")\n",        name, AParentNames[name]        >> initfile;
	printf"dbpf(\"%s:SubNodeNames\",\"%s\")\n",      name, ASubNodeNames[name]       >> initfile;
	printf"dbpf(\"%s:ElementNames\",\"%s\")\n",      name, AElementNames[name]       >> initfile;
	printf"dbpf(\"%s:ElementRecordNames\",\"%s\")\n",name, AElementRecordNames[name] >> initfile;
	printf"dbpf(\"%s:ElementRecordTypes\",\"%s\")\n",name, AElementRecordTypes[name] >> initfile;
	printf"dbpf(\"%s:NodeRecordNames\",\"%s\")\n",   name, ANodeRecordNames[name]    >> initfile;
	printf"dbpf(\"%s:NodeRecordTypes\",\"%s\")\n",   name, ANodeRecordTypes[name]    >> initfile;
    }
    printf"}\n" >> subfile;	    #close the bracket for the list of macro lines in the sub file.
}



function printDict(dict){    #Print python dictionaries for the benefit of css or other python things.
    
    printTopComments(dict);

    print "" >> dict;
    print "#Create the dictionaries to describe the nodes" >> dict; 
    print "ParentName             = {}" >> dict;
    print "Depth                  = {}" >> dict;
    print "SubNodeCount           = {}" >> dict;
    print "SubNodeNames           = {}" >> dict;
    print "ElementCount           = {}" >> dict;
    print "ElementNames           = {}" >> dict;
    print "ElementRecordCount     = {}" >> dict;
    print "ElementRecordNames     = {}" >> dict;
    print "ElementRecordTypes     = {}" >> dict;
    print "NodeRecordCount        = {}" >> dict;
    print "NodeRecordNames        = {}" >> dict;
    print "NodeRecordTypes        = {}" >> dict;
    print "" >> dict;
    
    print "#Populate the dictionaries with the info for all the nodes" >> dict; 
    print "" >> dict;
    
    for(n=1;n<=nNodes;n++){
	name = ANodeNames[n];           #get the node name for simplicity
	
	printf("ParentName['%s']             = \"%s\"\n",name,AParentNames[name]) >> dict;
	printf("Depth['%s']                  = \"%s\"\n",name,ADepth[name]) >> dict;
	printf("SubNodeCount['%s']           = \"%s\"\n",name,ASubNodeCount[name]) >> dict;
	printf("SubNodeNames['%s']           = \"%s\"\n",name,ASubNodeNames[name]) >> dict;
	printf("ElementCount['%s']           = \"%s\"\n",name,AElementCount[name]) >> dict;
	printf("ElementNames['%s']           = \"%s\"\n",name,AElementNames[name]) >> dict;
	printf("ElementRecordCount['%s']     = \"%s\"\n",name,AElementRecordCount[name]) >> dict;
	printf("ElementRecordNames['%s']     = \"%s\"\n",name,AElementRecordNames[name]) >> dict;
	printf("ElementRecordTypes['%s']     = \"%s\"\n",name,AElementNodeRecordTypes[name]) >> dict;
	printf("NodeRecordCount['%s']        = \"%s\"\n",name,ANodeRecordCount[name]) >> dict;
	printf("NodeRecordNames['%s']        = \"%s\"\n",name,ANodeRecordNames[name]) >> dict;
	printf("NodeRecordTypes['%s']        = \"%s\"\n",name,ANodeRecordTypes[name]) >> dict;	
	print "" >> dict;
    }
}

function promptMe(myLine,   yn){     #Get user response to a question

    print"";
    printf("%s? (y/n): ", myLine)
    getline yn < "-"
    
    return tolower(yn)
}


function printTopComments(file){
    printf("# WARNING: DO NOT EDIT. This file was geneated at %s by the a command like this:\n",strftime()) > file;
    printf("# ./parseEpicsRecordDump [options] ioc1.dump ioc2.dump .... \n") >> file;
    printf("# See the CLAS12 Slow Controls wiki for manuals, or the README in this directory\n")    >> file;
    printf("#\n")    >> file;
}


function addToStringInArray(array, ind, str, sep, unique){
    #append str to array[ind] -  if unique=1, check it's not already there
    if(!array[ind]) {                            #if the string is empty
	array[ind] = str;                        #just copy and return
	return 1;
    }
    if(!unique){                                 #if we dont care about it being unique, append and return
	array[ind] = sprintf("%s%s%s",array[ind],sep,str);
	return 1;
    }
    #split and check all substrings for existing copy of str    
    nsub=split(array[ind],parts,sep);
    for(ss=1;ss<nsub;ss++){                
	if(parts[ss]==str) return 0;             #if copy of str is already there, return 0
    }

    array[ind] = sprintf("%s%s%s",array[ind],sep,str); #append
    return 1;
}
