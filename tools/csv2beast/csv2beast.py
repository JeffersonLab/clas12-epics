#!/usr/bin/env python
#
# Convert CSV to XML for BEAST configuration
#
# Usage:
#   csv2beast.py [FILE...] [DIR...]
#
#   Excepts combinations of files and directories (default: ./).  Output file(s) will be the
#   same as the input, only with xml extension.
#
# Input format:
#   Line 1: <config name>, <component 0>, <component 1>, <component N>, ...
#   Line 2: column headers (Must start with pv)
#   Line 3: data (Must start with pv name)
#
# Input example:
#   HallB, Torus, Vacuum
#   pv, description, latching, annunciating, display title, display details
#   B_TORUS:LC817A1, Torus Load Cell, true, true, Open Force GUI, /CLAS12_Share/blah-blah
#
# Output example:
#   <?xml version="1.0"?>
#   <config name="HallB">
#	    <component name=" Torus">
#	    <component name=" Vacuum">
#   		<pv name="B_TORUS:FOR:CCM_A:LC817A1">
#   			<description>Torus Load Cell</description>
#   			<latching>true</latching>
#   			<annunciating>true</annunciating>
#               <display>
#                   <title>Open Force GUI</title>
#                   <details</CLAS12_Share/blah-blah</details>
#               </display>
#   		</pv>
#       </component>
#       </component>
#   </config>
#
# Author: Wesley Moore (wmoore@jlab.org)
# Date:   May 2016
#

import sys
import glob
import os
import csv
from xml.etree.ElementTree import Element, SubElement, Comment, tostring
from xml.dom import minidom

# Fix for elementtree.tostring() error (UnicodeDecodeError: 'ascii' codec can't
# decode byte 0xe2 in position ##).  Error created by using " in elements.
reload(sys)
sys.setdefaultencoding('utf-8')

def pretty_print(elem):

    rough_string = tostring(elem, "utf-8")
    reparsed = minidom.parseString(rough_string)
    return reparsed.toprettyxml(indent="    ")

csvFiles = []

if len(sys.argv) < 2:
    csvFiles = glob.glob("./*.[cC][sS][vV]")
else:
    for arg in sys.argv[1:]:
        if os.path.isfile(arg):
            csvFiles.append(arg)
        elif os.path.isdir(arg):
            if not arg.endswith('/'):
                arg += '/'
            arg += "*.[cC][sS][vV]"
            csvFiles = glob.glob(arg)
        else:
            print "Warning: " + arg + " not found"

if len(csvFiles) == 0:
    print "No files to be processed"
    exit(0)

csvFiles.sort(key=str.lower)

for csvFile in csvFiles:
    if os.stat(csvFile).st_size == 0:
        print "Warning: empty file, skipping " + csvFile
        continue

    print "Processing BEAST file " + csvFile
    xmlFile = csvFile[:-4] + '.xml'
    csvData = csv.reader(open(csvFile))
    try:
        xmlData = open(xmlFile, 'w')
    except IOError:
        print "Write permission denied: " + xmlFile
        exit(1)

    rowNum = 0
    for row in csvData:
        row = map(str.strip, row)
        # config and nested component levels
        if rowNum == 0:
            levels = row
            for i in range(len(levels)):
                if i == 0:
                    tree = Element('config', name=levels[i])
                    tree.append(Comment(" Generated by csv2beast.py "))
                elif i == 1:
                    comp = SubElement(tree, 'component', name=levels[i])
                elif levels[i] != "":
                    comp = SubElement(comp, 'component', name=levels[i])
        # store tag names
        elif rowNum == 1:
            tags = row
            if tags[0].lower() != "pv":
                print "Error: 'pv' must be the first column, found '" + tags[0] + "' instead"
                exit(1)
        # parse pv rows
        elif rowNum > 1:
            vals = row
            i = 0
            if vals[i] == "":
                # no pv defined, skipping...
                continue
            while i < len(tags):
                if tags[i].lower() == "pv":
                    pv = SubElement(comp, 'pv', name=vals[i])
                elif (' ' in tags[i]):
                    # sub elements (ex. automated_action, display)
                    elem = tags[i].split()
                    sub0_name = elem[0]     # store to check for duplicates
                    sub1_name = elem[1]
                    if vals[i] != '':
                        sub1 = SubElement(pv,   elem[0])
                        sub2 = SubElement(sub1, elem[1])
                        sub2.text = vals[i]
                    j = i+1
                    while j < len(tags):
                        # search until not a sub-element
                        if tags[j] == sub0_name:
                            print "dup"
                            break
                        elem = tags[j].split()
                        if elem[0] == sub0_name:
                            if elem[1] == sub1_name:
                                # duplicate element (ex. multiple displays, etc)
                                break
                            else:
                                if vals[j] != '':
                                    sub3 = SubElement(sub1, elem[1])
                                    sub3.text = vals[j]
                                j+=1
                        else:
                            break
                    i = j-1 # skip to this column
                else:
                    # sub elements of pv
                    if vals[i] != '':
                        elem = SubElement(pv, tags[i])
                        elem.text = vals[i]
                i+=1
        rowNum += 1

    #print pretty_print(tree)
    xmlData.write(pretty_print(tree))
    xmlData.close()
